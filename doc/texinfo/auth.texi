@c This is part of the Radius manual.
@c Copyright (C) 1999,2000,2001 Sergey Poznyakoff
@c See file radius.texi for copying conditions.
@comment *******************************************************************
@node Authentication, Accounting, Configuration Files, Top
@chapter Authentication

An @dfn{Authentication Type} specifies which credentials the user
is required to supply in order to be authenticated and where the
user's authentication data are stored. It is defined by the value
of @attr{Auth-Type} attribute in @LHS{} of a @file{users} entry.

@menu
* Accept Auth::                   Accept unconditionally.
* Reject Auth::                   Reject unconditionally.
* Local Password Auth::           Authenticate using plaintext password.
* Encrypted Password Auth::       Authenticate using MD5 encrypted password.
* System Auth::                   Authenticate using system account.
* SQL Auth::                      Authenticate using SQL.
* PAM Auth::                      Authenticate using PAM.
* Custom Auth::                   Defining Custom Authentication Types.
* Checking Simultaneous Logins::  
@end menu

@comment *L2****************************************************************
@node Accept Auth
@section Accept Authentication Type
@cindex Accept Authentication Type
@cindex Guest accounts, setting up
@exindex Guest accounts, setting up

@dfn{Accept} is the simplest authentication type. Users with this
authentication type will be authenticated successfully without checking
any credentials. Actually this means that only username
is required for authentication.

This authentication type is used for each @file{users} entry, whose
@LHS{} contains

@example
Auth-Type = Accept
@end example
@noindent

This authentication type can be used for guest accounts, e.g. the
following profile in @file{users}:

@example
@group
guest   Auth-Type = Accept,
                Simultaneous-Use = 10
        Service-Type = Framed-User,
                Framed-Protocol = PPP
@end group
@end example

@noindent
allows up to 10 simultaneous guest PPP accounts. To log in using such
guest account it is sufficient to use username @samp{guest} and any
password.

@comment *L2****************************************************************
@node Reject Auth
@section Reject Authentication Type
@cindex Reject Authentication Type
@cindex Disabling user accounts

The @dfn{Reject} authentication type causes the request to be rejected
unconditionally. It can be used to disable a user account (For another
method of disabling user accounts, @pxref{access.deny file}).

This authentication type is used for each @file{users} entry, whose
@LHS{} contains

@example
Auth-Type = Reject
@end example

@comment *L2****************************************************************
@node Local Password Auth
@section Local Password Authentication Type
@cindex Local Password Auth
@cindex CHAP

The @dfn{Local Password} authentication type allows to keep plaintext
user passwords. Although the use of this authentication type is strongly
discouraged for security reasons, this is the only
authentication type that can be used with @acronym{CHAP} authentication.

There are two ways of using this authentication type

@subheading Specifying Passwords in users File.
To keep the plaintext passwords in @file{users} file, the profile
entry must follow this pattern:

@example
@group
@var{user-name}  Auth-Type = Local,
                     Password = @var{plaintext}
@end group
@end example

The @var{plaintext} is the user's plaintext password. Obviously,
@var{user-name} may not be @code{DEFAULT} nor @code{BEGIN}.

@subheading Specifying Passwords in SQL Database.

@example
@group
@var{user-name}   Auth-Type = Local,
                      Password-Location = SQL
@end group
@end example

When the user is authenticated using such profile, its password
is retrieved from the authentication database using @code{auth_query}.
The configuration of @acronym{SQL} authentication is described in
detail in @ref{Authentication Server Parameters}.

@comment *L2****************************************************************
@node Encrypted Password Auth
@section Encrypted Password Authentication Type
@cindex Encrypted Password Authentication Type

The @dfn{Encrypted Password} type allows to keep user's passwords
encrypted via @acronym{DES} or @acronym{MD5} algorythm. There are
two ways of using this authentication type.

@subheading Specifying Passwords in users File.

@example
@var{user-name}  Auth-Type = Crypt-Local,
                     Password = @var{crypt-pass}
@end example
@noindent

The @attr{Crypt-Password} is a shortcut for the above notation:

@example
@var{user-name}  Crypt-Password = @var{crypt-pass}
@end example

@subheading Specifying Passwords in SQL Database.

@example
@group
@var{user-name}   Auth-Type = Crypt-Local,
                      Password-Location = SQL
@end group
@end example

Using this profile, the user's password is retrieved from the
authentication database using @code{auth_query}.
The configuration of @acronym{SQL} authentication is described in
detail on @ref{Authentication Server Parameters}.

The shortcut for this notation is @code{Auth-Type = SQL}.

In any case, the passwords used with this authentication type
must be either @acronym{DES} or @acronym{MD5} hashed.

@comment *L2****************************************************************
@node System Auth
@section System Authentication Type
@cindex System Authentication Type

The @dfn{System} authentication type requires that the user
have a valid system account on the machine where the radius
server is running. The use of this type is triggered by setting

@example
Auth-Type = System
@end example
@noindent

in the @LHS{} of a @file{users} entry.

@comment *L2****************************************************************
@node SQL Auth
@section SQL Authentication Type
@cindex SQL Authentication Type

Setting @code{Auth-Type = SQL} or @code{Auth-Type = Mysql}
in the @LHS{} of a @file{users} entry is a synonim for

@example
Auth-Type = Crypt-Local, Password-Location = SQL
@end example
@noindent

and is provided as a shortcut and for backward compatibility with
previous versions of GNU Radius.

For description of @acronym{SQL} authentication, @xref{Encrypted
Password Auth}. The configuration of @acronym{SQL} subsystem
is described in @xref{sqlserver file}.

@comment *L2****************************************************************
@node PAM Auth
@section PAM Authentication Type
@cindex PAM Authentication Type

@dfn{PAM} authentication type indicates that a user should be authenticated
using @acronym{PAM} (Pluggable Authentication Module) framework. The
simplest way of usage is:

@example
Auth-Type = PAM
@end example
@noindent

Any user whose @file{users} profile contains the above, will be
authenticated via @acronym{PAM}, using service name @samp{radius}.
If you wish to use another service name, set it using @attr{Auth-Data}
attribute, e.g.:

@example
Auth-Type = PAM,
    Auth-Data = @var{pam-service}
@end example

@comment *L2****************************************************************
@node Custom Auth
@section Defining Custom Authentication Types
@cindex Custom Authentication Types

The are three ways to define custom authentication types:

@enumerate 1
@item Write a @acronym{PAM} module.
@item Use a Guile procedure.
@item Use an external program
@end enumerate

You can write a @acronym{PAM} module implementing the new authentication
type. Then, specifying @code{Auth-Type = PAM} allows to apply
it (@pxref{PAM Auth}).

Alternatively, you may write a Scheme procedure implementing the new
authentication type. To apply it, use @attr{Scheme-Procedure} attribute
in @RHS{}. The @code{Auth-Type = Accept} can be used in @LHS{} if
the whole authentication burden is to be passed to the Scheme procedure.
For example, if one wrote a procedure @code{my-auth}, to apply it to
all users, one will place the following profile in his @file{users}
file:

@example
@group
DEFAULT  Auth-Type = Accept
         Scheme-Procedure = "my-auth"
@end group
@end example

For a discussion of how to write Scheme authentication procedures,
@xref{Authentication with Scheme}.

The third way to implemement your own authentication method is using
an external program. This is less effective than the methods described
above, but may be necessary sometimes. To invoke the program, use
the following statement in the @RHS{} of @file{users} entry:

@example
Exec-Program-Wait = "@var{progname} @var{args}"
@end example
@noindent

The @var{progname} must be the full path to the program, @var{args} ---
any arguments it needs. The usual substitutions may be used in
@var{args} to pass any request attributes to the program
(@pxref{Macro Substitution}).

For a detailed description of @attr{Exec-Program-Wait} attribute and
an example of its use, @xref{Exec-Program-Wait}.

@comment *L2****************************************************************
@node Checking Simultaneous Logins
@section Checking Simultaneous Logins
@cindex Checking Simultaneous Logins
@cindex Simultaneous logins, checking for

The number of sessions a user can have open simultaneously can be
restricted by setting @attr{Simultaneous-Use} attribute in the user's
profile @LHS{} (@pxref{Simultaneous-Use}). By default the number
of simultaneous sessions is unlimited.

When a user with limited number of simultaneous logins authenticates
himself, Radius first counts the number of the sessions that are already
opened by this user.
If this number is equal to the value of @attr{Simultaneous-Use}
attribute the authentication request is rejected.

To determine the number of open sessions, Radius scans the
@file{radlog/radutmp} for any open entries marked with the
user's login name @ref{UNIX Accounting}. Such entries are created
when Radius receives an Accounting-Request packet with
@attr{Acct-Status-Type} attribute set to @code{Start}. An entry is
marked closed when a corresponding Accounting-Request packet arrives with
@attr{Acct-Status-Type} attribute set to @code{Stop}.

Since an open entry might be a result of missing @code{Stop} packet,
Radius queries the @NAS{} whether the session listed in the entry is
currently active. If the @NAS{} replies positive, the session count
is incremented, if it replies negative, such entry is marked as
closed and is not counted. There may also be cases when the @NAS{}
is unreachable due to some reasons. In such cases the Radius behavior
is determined by the value of @code{checkrad-assume-logged} in
@file{config} file @ref{auth,,auth statement (raddb/config)}.
If the value is @code{yes}, Radius assumes the session is still
active and increases the session count, otherwise it proceeds as
if the @NAS{} returned negative reply.

To query a @NAS{}, Radius first looks up its type and additional parameters
in @file{naslist} file (@pxref{naslist file}). If the @NAS{} type is @samp{true},
Radius acts as if the @NAS{} returned 1, if the type is @samp{false}, it
acts as if the @NAS{} returned 0, otherwise it looks up the entry
in the @file{nastypes} which has matching type (@pxref{nastypes file}).
If such entry does not exist, Radius issues the error message and
acts accordingly to the value of configuration variable
@code{checkrad-assume-logged}.
Otherwise, Radius determines the query method to use from the second
field of this entry, and constructs its arguments by appending
arguments from the @file{naslist} entry to those of @code{nastypes}
entry. @emph{Please note}, that the former take precedence over the
latter, and can thus be used to override default values specified
in @file{nastypes}.

Having determined the query method and its argument, Radius queries
@NAS{} and analyzes its output by invoking a user-supplied
Rewrite function. The function to use
is specified by the @code{function=} argument to the method. It is
called each time a line of output is received from the @NAS{} (for
finger queries) or a variable is received (for SNMP queries). The
process continues until the function returns 1 or the last line
of output is read or a timeout occurs whichever comes first.

If the user-function returns 1 it is taken to mean the user's session is
now active at the @NAS{}, otherwise, if it replies 0 or if the end of
output is reached, it is taken to mean the user's session is not active.

The syntax conventions for user-supplied functions are described in
detail in @ref{Login Verification Functions}.

